---
import { Image } from "astro:assets";
import brandImg from "../images/brand.png";
import toSlug from "../helpers/toSlug.mts";
import debounce from "../helpers/debounce.mts";

interface Props {
  id: string;
  classes: string;
  autoHide?: boolean;
}

// NOTE: I'm not sure how get it in build time at this moment, probably i18n will be useful here
const sections = ["O nas", "Projekty", "Wsparcie", "Kontakt", "Wspieraj nas"];
const { id, classes, autoHide } = Astro.props;
---

<style>
  .element-0 {
    @apply row-start-3 row-end-3 md:row-start-4 md:row-end-4 indent--30px;
  }

  .element-1 {
    @apply row-start-4 row-end-4 md:row-start-5 md:row-end-5;
  }

  .element-2 {
    @apply row-start-5 row-end-8 md:row-start-6 md:row-end-8 flex items-center;
  }

  .element-2 span {
    @apply font-bold text-2xl text-white md:text-4xl md:text-black;
  }

  .element-3 {
    @apply row-start-8 row-end-8;
  }

  .element-4 {
    @apply row-start-9 row-end-9 indent--30px;
  }
</style>

<nav id={id} class={classes} data-wheel-auto-hide={autoHide?.toString?.()}>
  <div class="translate-x--1/2 md:translate-x--1/3 translate-y-1/2">
    <div
      class="grid gap-10"
      style={{ gridTemplateColumns: "max-content max-content" }}
    >
      <div class="w-300px md:w-500px">
        <Image class="navigation-wheel" src={brandImg} alt="brand" />
      </div>
      <div>
        <div
          id="navigation-wheel-items"
          class="h-full max-h-full grid grid-rows-12 navigation-wheel-items"
        >
          {
            sections.map((section, index) => {
              return (
                <div
                  class:list={[`element-${index}`]}
                  data-wheel-item-index={index}
                  data-wheel-item-slug={toSlug(section)}
                >
                  <span class="text-lg text-white md:text-3xl md:text-#a6a6a6">
                    <a href="#">{section}</a>
                  </span>
                </div>
              );
            })
          }
        </div>
      </div>
    </div>
  </div>

  <script>
    import debounce from "../helpers/debounce.mts";

    let currentRotate = -30;
    const MAX_ITEMS_IN_WHEEL = 5;

    const setActiveItem = (index: number, withoutAnim: boolean) => {
      const newActive = document.querySelector(
        `[data-wheel-item-index='${index}']`,
      );

      const currentActive = document.querySelector(
        `[data-wheel-item-index].element-2`,
      );

      if (!newActive || !currentActive) return;

      // NOTE: Oh god move it...
      const newActiveElNumberClass = parseInt(
        newActive.className.at(
          newActive.className.indexOf("element-") + "element-".length,
        ) ?? "",
      );

      const newActiveItemIndex = parseInt(
        newActive.getAttribute("data-wheel-item-index") ?? "",
      );

      if (withoutAnim) {
        const activeItemIndex = parseInt(
          currentActive.getAttribute("data-wheel-item-index") ?? "",
        );

        if (activeItemIndex === index) return;

        const movement = 2 - newActiveElNumberClass;
        document.querySelectorAll("[data-wheel-item-index]").forEach((el) => {
          const elItemIndex = parseInt(
            el.getAttribute("data-wheel-item-index") ?? "",
          );

          const elementNumberClass = parseInt(
            el.className.at(
              el.className.indexOf("element-") + "element-".length,
            ) ?? "",
          );

          const nextElNumberClass =
            (MAX_ITEMS_IN_WHEEL + (elementNumberClass + movement)) %
            MAX_ITEMS_IN_WHEEL;

          el.classList.toggle(`element-${elementNumberClass}`);
          el.classList.toggle(`element-${nextElNumberClass}`);
          if (
            (elItemIndex > newActiveItemIndex && 2 > nextElNumberClass) ||
            (newActiveItemIndex > elItemIndex && nextElNumberClass > 2)
          ) {
            el.classList.add("hidden");
          } else {
            el.classList.remove("hidden");
          }
        });
      }
    };

    const navigationWheels = document.querySelectorAll(".navigation-wheel");
    navigationWheels.forEach((navigationWheel) => {
      const nav = navigationWheel.closest("nav");
      const autoHide = nav?.getAttribute("data-wheel-auto-hide");
      const navigationWheelItems = nav?.querySelector(
        ".navigation-wheel-items",
      );

      if (!navigationWheel || !navigationWheelItems || !nav)
        throw Error("Can't find wheel");

      const observer = new IntersectionObserver(
        (entries) => {
          debounce<(entries: IntersectionObserverEntry[]) => void>(
            (entries) => {
              let anyIntersect = false;
              entries.forEach(({ isIntersecting, target }) => {
                if (isIntersecting) {
                  anyIntersect = true;
                  const newItemSlug =
                    target.getAttribute("data-section-slug") ?? "";
                  const newActiveIndex = parseInt(
                    document
                      .querySelector(`[data-wheel-item-slug='${newItemSlug}']`)
                      ?.getAttribute("data-wheel-item-index") ?? "",
                  );

                  const currentActiveIndex = parseInt(
                    document
                      .querySelector(`.element-2`)
                      ?.getAttribute("data-wheel-item-index") ?? "",
                  );

                  let nextRotate =
                    currentRotate +
                    (currentActiveIndex > newActiveIndex ? 30 : -30);
                  const anim = navigationWheel.animate(
                    [
                      { transform: `rotate(${currentRotate}deg)` },
                      { transform: `rotate(${nextRotate}deg)` },
                    ],
                    {
                      duration: 450,
                      fill: "forwards",
                    },
                  );

                  anim.finished.then(() => {
                    currentRotate = nextRotate;
                    if (navigationWheel.getBoundingClientRect().width) {
                      anim.commitStyles();
                      anim.cancel();
                    }

                    setActiveItem(newActiveIndex, true);
                  });
                }
              });

              if (autoHide) {
                if (anyIntersect) {
                  if (nav.classList.contains("hidden")) {
                    nav.classList.remove("hidden");
                    nav.animate(
                      [
                        { transform: `translateX(-50%)` },
                        { transform: `translateX(0)` },
                      ],
                      {
                        duration: 450,
                      },
                    );
                  }
                } else {
                  nav
                    .animate(
                      [
                        { transform: `translateX(0)` },
                        { transform: `translateX(-50%)` },
                      ],
                      {
                        duration: 450,
                      },
                    )
                    .finished.then(() => {
                      nav.classList.add("hidden");
                    });
                }
              }
            },
            150,
          )(entries);
        },
        {
          rootMargin: "-50% 0% -50% 0%",
        },
      );

      document.querySelectorAll("section").forEach((el) => {
        observer.observe(el);
      });
    });
  </script>
</nav>
